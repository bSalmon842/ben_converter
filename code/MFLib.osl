//pw color correct function
color MF_colourCorrect(color inColor, float brightness, float desaturate, float gammaPower, float hueShift, color tint)
{
	color hsv = transformc("rgb", "hsv", inColor);
	hsv[0] += hueShift;
	hsv[1] = hsv[1] * (1 - desaturate);
	color col = transformc("hsv", "rgb", hsv);
	col *= brightness;
	col = pow(col, gammaPower);
	col *= tint;
	return col;
}

//IDmap functions
//--------------------------------
float CMF_IDBlendingScalar(float InLayer, float InBase, float InIDmap, int InIDIndex)
{
	float a = clamp(abs(InIDmap - InIDIndex), 0, 1);
	return mix(InLayer, InBase, a);
}

float MF_MATID_picker(int ID_Index, float IDmap)
{
	float f = ceil(IDmap * 16);
	return CMF_IDBlendingScalar(1, 0, f, ID_Index);
}
//--------------------------------
//EndID map functions

//tims savage makeup function for skin
MaterialAttributes MF_makeup(
	//material in
	MaterialAttributes inMaterial, 
	//color controls
	color MakeUpcolourR, 
	color MakeUpcolourG, 
	color MakeUpcolourB,
	color MetalPowderColorBurst, 
	color MU_mask, 
	float makeupColourRatio,
	//roughness controls
	float MuRoughBase,
	//sss controls
	float makeupSS,
	//Metallic Controls
	float MetalPowderTiling,
	float MetallicContractScale,
	float MetalPowderMaskRatio,
	float MakeUpMetallicValue_low,
	float MakeUpMetallicValue_hi,
	color noiseMap
	)
{
	//texture lookup
	point metalFlakeUV =  MetalPowderTiling * point(u, 1 - v, 0);
	//color noiseMap = texture("P:/Gemini/3d/MaterialLibrary/_Resources/CHA/noise_P.TGA", metalFlakeUV.x, metalFlakeUV.y);

	//Base color
	MaterialAttributes outMaterial = inMaterial;
	color makeupRGB = mix(mix(MakeUpcolourB, MakeUpcolourR, MU_mask.r), MakeUpcolourG, MU_mask.g);
	float makeupAlpha = MU_mask.r + MU_mask.g + MU_mask.b;
	makeupAlpha = clamp(makeupAlpha, 0, 1);

	makeupRGB = mix(outMaterial.BaseColor, makeupRGB, makeupColourRatio);
	makeupRGB = mix(outMaterial.BaseColor, makeupRGB, makeupAlpha);
	outMaterial.BaseColor = (mix(0.0, MetalPowderColorBurst, FresnelUE4(1))) + makeupRGB;

	//Roughness
	outMaterial.Roughness =  mix(inMaterial.Roughness, mix(0.0, MuRoughBase, inMaterial.Roughness), makeupAlpha);

	//SSS
	outMaterial.Opacity = mix(inMaterial.Opacity, (inMaterial.Opacity * makeupSS), makeupAlpha);
	//metallic
	float metalMask = mix(1, 0, MU_mask.b);
	metalMask = clamp(1-(pow(metalMask, MetalPowderMaskRatio)), 0, 1);
	float metalDetail = CheapContrast(noiseMap.g, MetallicContractScale);
	metalDetail = metalDetail * metalMask;
	metalDetail = mix(MakeUpMetallicValue_low, MakeUpMetallicValue_hi, metalDetail);
	outMaterial.Metallic = mix(0, metalDetail, MU_mask.b);

	//normal

	return outMaterial;
}

point uvChannel(int channel, CoordinateGroup uvInput)
{	
	if(channel == 1)
	{
		return uvInput.uvCoords;
	}
	else if (channel == 2)
	{
		return uvInput.uvCoords1;
	}
	else if (channel == 3)
	{
		return uvInput.uvCoords2;
	}
	else if (channel == 4)
	{
		return uvInput.uvCoords3;
	}
}

color pwTextureSample(string FileName, point UV, int UDIM, int sRGB)
{
    float ulookup = UV.x;
	float b = TEST_def;
	float vlookup = 1.0 - UV.y;
    if (UDIM)
	{
		float vfloor  = floor(UV.y);
		float vfrac   = UV.y - vfloor;
		vlookup = vfloor + (1.0 - vfrac);
	}
    color sample = texture(FileName, ulookup, vlookup);
    if(sRGB)
    {
        return pow(sample, 2.2);
    }
    else
    {
        return sample;
    }
}
